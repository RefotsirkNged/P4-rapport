\chapter{Implementation}
This chapter explains the different phases of the \lang{} compiler, and how they were implemented for the \lang{} compiler. The \lang{} compiler has several distinct phases, as seen on \ref{fig:compphase}. 


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{resources/Images/compiler-phase.jpeg}
    \caption{A generalized figure of the phases of the \lang{} compiler.}
    \label{fig:compphase}
\end{figure}

These phases are:

\begin{itemize}
    \item Library injection
    \item Scanner and Parser
    \item Type checker
    \item Code generator
    \item Java Compiler
\end{itemize}

The \lang{} compiler, as a whole, takes a file with code written in \lang{} as input and outputs an executable Java program.

The first thing that happens when a user wants to compile a \lang{} file in the \lang{} compiler, is that the \lang{} libraries are injected into the user's file. This is done to include the libraries in the AST, so that they are present when the type checker is run.

After the libraries are added to the source file, the file is run through the scanner and parser, which is generated by SableCC. This phase returns an AST of the program, which is used throughout the rest of the compiler.

The next phase, the type checker, performs a tree walk of the AST. During the walk, the type checker adds each node to a hash table with a reference to the node and the type of the node, adds all variables, methods and classes to a symbol table, validates the types of a node's child nodes and checks if the different variables, methods and classes are within the scope. When the type checking phase is complete, it is known whether or not the \lang{} program is semantically correct. The type table is also returned for use in the code generation phase of the compiler.

When the source program is confirmed to be a valid program in \lang{}, the code generation phase is initiated. In this phase, a new tree walk is done over the AST and code is generated for each node. When this phase is completed, a number of java files have been generated, which is afterwards run trough the final phase of the compiler, namely the Java Compiler.

The following sections gives a more in-depth explanation of the different phases of the \lang{} compiler, but before that, the Depth First adapter, used for the different tree walks, is explained.

\section{SableCC's Depth first adapter}
SableCC provides a depth first adapter class, which is intended to be used in later phases of the compiler to traverse the AST for analysis and code-generation purposes. When implementing the analysis and codegen phases, the depth-first adapter class can simply be extended, which, in the end, saves development time and reduces the amount of errors that could be introduced when implementing the compiler. The adapter implements two functions for each Node type in the AST. These are an \textit{in} and \textit{out} function. The \textit{in} function is called each time the tree walker enters, i.e the first time it visits a node, and the \textit{out} function is called when the tree walker has visited the whole sub-tree rooted in that node, i.e when it exits a node. An example template of how these \textit{in} and \textit{out} functions could look for a "Prog" node, which is always the first node to be created in the AST, is shown below:
\begin{figure}[H]
    \centering
    
    \begin{lstlisting}[style=gglang]
    public void inAProg(AProg node){
        
        //Some code to be executed on node entry here
    
    }
    public void outAProg(Aprog node){
    
        //Some code to be executed on node exit here
        
    }
    
    \end{lstlisting}
    \caption{Example for how the in and out methods are used in the \lang{} compiler\label{fig:inout}}
\end{figure}
There is of course a lot of other nodes, which can be found in the AST grammar in appendix \ref{AST}.
The different kinds of actions, that are needed in the analysis and code generation phases, are hereafter implemented as extensions of the DepthFirstAdapter class. This approach is used through the rest of the compiler. 

\input{sections/Implementation/Syntax.tex}
\input{sections/Implementation/Semantic.tex}
\input{sections/Implementation/Codegen.tex}


\section{The GUI of the \lang{} compiler}
In order to help ease the use of the \lang{} compiler, a simple GUI was created using Java Swing\cite{swing}. The only features it implements is a way to target a text file for compilation, followed by a button to execute the compilation. After the compilation is done, it opens the folder with the finished game. It looks as seen on figure \ref{fig:GUI}.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{resources/Images/Udklip.PNG}
\caption{The \lang{} GUI.)}\label{fig:GUI}
\end{figure}

The following section describes and presents the tests made on the \lang{} compiler.