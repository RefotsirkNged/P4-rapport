\section{Type checker phase}
\label{sec:semanticAnal}
Besides generating a parser, SableCC also generates a \textit{tree walking} class, which can traverse the AST. This is done using a modified version of the visitor pattern, implemented by SableCC. 

To implement the type and scoping rules, defined formally in chapter \ref{chap:semantics}, a new class has been created, called \textit{TypeChecker}. This class inherits from a class generated by SableCC, called \textit{DepthFirstAdapter}, as described in the introduction to this chapter.  The \textit{in} and \textit{out} functions, that is described for all Nodes, will be used to implement the type and scoping rules. 

\subsection{Symbol table and scope}
The symbol table is implemented as a stack of \textit{hash tables}, indexed by an id string, i.e. the id of the variable or function in question, and value of a reference to the node where it is declared. Each time a new scope is opened, a new \textit{hash table} is pushed to the stack, and when a scope is closed, the hash table on top of the stack is removed. This makes sure that the current scope is always on top of the stack, and that only the nodes in scope are located in memory. 


\begin{figure}[H]
\centering
\begin{lstlisting}[]

    private void openScope(Node node){
        TableFiller tf = new TableFiller(node);

        node.apply(tf);

        symStack.push(tf.symStack.pop());
        typeTable.putAll(tf.typeTable);
        ErrorList.addAll(tf.ErrorList);
    }
    
\end{lstlisting}
\caption{Code example: \textit{openScope}}
\label{fig:openscope}
\end{figure}

When a new scope is opened, the function shown on figure \ref{fig:openscope} is called. This function initiates a new instance of the \textit{TableFiller} class, which also inherits from the \textit{DepthFirstAdapter}. When the TableFiller object is applied to a node, as seen on line 5 of figure \ref{fig:openscope}, it initiates a tree walk over the subtree with that node as the root. During this tree walk, it fills its own symbol table, by adding to it each time it encounters a declaration node. This symbol table is then popped, and the result is added to the actual symbol table stack, as seen on line 7.

This pass is done to make it possible to call a function or class that has not yet been declared in the code.

The TableFiller class implements \textit{out} functions for all the declaration nodes and \textit{in} functions for some of them.

To add a symbol to the symbol table, a function called addSymbol is called. This function is seen on figure \ref{fig:addsymbol}. The \textit{addSymbol} function takes a name and a node as parameters. These are the values that are added to the symbol table.

\begin{figure}[H]
\centering
\begin{lstlisting}[]

    private void addSymbol(String name, Node node){
        if (!symStack.peek().containsKey(name)) {
            symStack.peek().put(name, node);
        }
        else
            ErrorList.add("ERROR: " + name + " is already defined in this scope " + symStack.peek().size());
    }
    
\end{lstlisting}
\caption{Code example: \textit{addSymbol}}
\label{fig:addsymbol}
\end{figure}

Before adding the symbol to the symbol table, the function first makes a check to see if the symbol is already in the current scope (the symbol can be in an outer scope, since \lang{} has symbol shadowing). If the symbol is not found in the current scope, it is added, as seen on line 4 of figure \ref{fig:addsymbol}. If it is already in the current scope, an error message is added to an ArrayList called \textit{ErrorList}, which is a list of all the errors found. This will be used later on for displaying error messages.

To implement the dot operator, i.e '\textit{object\textbf{.}attribute}', the scope analyser must traverse the declaration sub tree for the class to check that it implements the attribute in question. This is done by applying the \textit{TableFiller} on the root of the class declaration sub tree. If a there are more than one level or more than one 'dot' in a call made with the dot operator, a new scope is opened for each class in the call with the current scope being the right most class in the call.



\subsection{Type Checker}
To implement the type rules, a new \textit{hash table} is used. This table is indexed by a node reference and its value is a string containing the type of that node. The value is a string and not a enum type, since in \lang{} the user can implement their own types. 

When talking about type checking, the nodes of the AST can be divided into four different categories, namely;

\begin{itemize}
    \item Nodes with no type.\\
    \textit{i.e main- and event-nodes}
    
    \item Nodes with a type. \\
    \textit{i.e value- and type-nodes}
    
    \item Nodes with a type, that is dependent of its child nodes.\\
    \textit{i.e function declaration- and expression-nodes}
    
    \item Nodes with no type, but with child nodes of a certain type.\\
    \textit{i.e if- and loop-nodes}
\end{itemize}

These different nodes are handled in different ways in the implementation of the type checker.

The first category of nodes are not handled in the type checking phase, since the nodes themselves always will be type-correct, and the type correctness of the child nodes will be validated on their respective nodes.

The second categories of nodes must be added to the type table. This is done by calling the function \textit{addType}, as seen on figure \ref{fig:addtype}. The call is made in the \textit{out} function of a node. The \textit{addType} function simply adds the node to the \textit{typeTable}. It is necessary to call \textit{trim()}, which removes white space at the start and end of the string.


\begin{figure}[H]
\centering
\begin{lstlisting}[]
    private void addType(Node node, String type){
        typeTable.put(node, type.trim());
    }
    
\end{lstlisting}
\caption{Code example: \textit{addType}}
\label{fig:addtype}
\end{figure}

An example of an \textit{out} function, as explained in \ref{sec:semanticAnal}, for a node in the second category can be seen on figure \ref{fig:outAFuncCall}.

\begin{figure}[H]
\centering
\begin{lstlisting}[]
    public void outAFuncCall(AFuncCall node){
        addType(node, getType(node.getId().getText()));
    }
    
\end{lstlisting}
\caption{Code example: \textit{outAFuncCall}}
\label{fig:outAFuncCall}
\end{figure}

Figure \ref{fig:outAFuncCall} shows how a node is added to the type table. In this example, the type is found by calling \textit{getType}, which searches the type-table. Some nodes, such as the different \textit{type} nodes, simply adds the string of their type.

The third category of nodes are the nodes whose type is dependent on the type of their child nodes. These include, but are not limited to, expression nodes.

Firstly, the child nodes' type is checked to evaluate if they meet the specification made in \ref{sec:TypeRules}. An example can be seen in the \textit{out} function of the \textit{plus-expression} node, as seen on figure \ref{fig:outAPlusExpr}.


\begin{figure}[H]
\centering
\begin{lstlisting}[]
    public void outAPlusExpr(APlusExpr node){
        if(typeTable.get(node.getLeft()).equals(TEXT) || typeTable.get(node.getRight()).equals(TEXT)){
            addType(node, TEXT);
        }
        else if(typeTable.get(node.getLeft()).equals(NUM)){
            if(typeTable.get(node.getRight()).equals(NUM)){
                addType(node, NUM);
            }
            else{
                ErrorList.add("ERROR line " + lineAndPos.getLine(node) + " pos " + lineAndPos.getPos(node) + " : " + node.getRight().toString() + ", is not of type " + NUM + ".");
                addType(node, ERRORTYPE);
            }
        }
        else{
            ErrorList.add("ERROR line " + lineAndPos.getLine(node) + " pos " + lineAndPos.getPos(node) + " : " + node.getLeft().toString() + ", is not of type " + NUM + ".");
            addType(node, ERRORTYPE);
        }
    }
    
\end{lstlisting}
\caption{Code example: \textit{outAPlusExpr}}
\label{fig:outAPlusExpr}
\end{figure}

In this example, if either of the child nodes are of type \textit{text}, the type of the whole expression is \textit{text}. The same goes for \textit{num}. If both these cases are false, an error is added to the ErrorList and the node gets the type \textit{ERRORTYPE}. This is done to allow the compiler to continue and collect all the errors, instead of stopping at the first type error encountered.

The fourth and last category of nodes are the nodes that are dependent on the type of one or more of their child nodes, but do not have a type themselves.

\begin{figure}[H]
\centering
\begin{lstlisting}[]
    public void outAForupStmt(AForupStmt node){
        closeScope();

        if(!typeTable.get(node.getExpr()).equals(NUM)){
            ErrorList.add("ERROR line " + lineAndPos.getLine(node.getExpr()) + " pos " + lineAndPos.getPos(node.getExpr()) + " : " + node.getExpr().toString() + ", is not of type " + NUM + ".");
        }

        if(!getType(node.getId().getText()).equals(NUM)){
            ErrorList.add("ERROR line " + lineAndPos.getLine(node.getId()) + " pos " + lineAndPos.getPos(node.getId()) + " : " + node.getId().toString() + ", is not of type " + NUM + ".");
        }
    }
    
\end{lstlisting}
\caption{Code example: \textit{outAForupStmt}}
\label{fig:outAForupStmt}
\end{figure}

An example of such a node is the \textit{ForupStmt} node. The \textit{out} function for this can be seen on figure \ref{fig:outAForupStmt}. This function only needs to control the types of the child nodes and thus not add anything to the type table.

Due to the fact that a function's type is not declared on the function declaration in \lang{}, the return type of the function must be found by examining the return node of the function declaration. To achieve this, the function declaration sub tree is traversed by applying the TypeChecker to the function declaration node. The type is then set to the type of the return node's expression child node. 

\subsubsection{Inheritance}
To obtain the inherited type of an object, it is necessary to add a new table, namely a super table. Each entry in the table contains two strings; one for the object's own type and one for the super type.

\subsubsection{Error handling}
If an error is encountered during compilation, one of two things can happen. If the error originates from the lexer/parser part of the compiler, for example a syntactical error, it is shown on the GUI, and compilation will be terminated. If the error, on the other hand, is from the semantic/contextual analysis phase, for example a semantic error, it is added to a List called errorlist, and the whole list is shown once the compilation is done or has reached a point where it cannot continue.

This concludes the section about the type-checker itself. The following chapter is about code-generation, and how it was implemented for the \lang{} compiler. 
